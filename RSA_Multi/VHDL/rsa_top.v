//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 4? 28 2020 14:57:12
//
//      Input file      : 
//      Component name  : rsa_top
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module rsa_top(clk, reset, valid_in, start_in, x, y, m, r_c, s, valid_out, bit_size);
   input            clk;
   input            reset;
   input            valid_in;
   input            start_in;
   input [15:0]     x;
   input [15:0]     y;
   input [15:0]     m;
   input [15:0]     r_c;
   output [15:0]    s;
   reg [15:0]       s;
   output           valid_out;
   reg              valid_out;
   input [15:0]     bit_size;
   
   
   reg              valid_in_mon_1;
   reg              valid_in_mon_2;
   wire             valid_out_mon_1;
   wire             valid_out_mon_2;
   reg              fifo_1_rd;
   reg              fifo_1_wr;
   
   reg [15:0]       a_mon_1;
   reg [15:0]       b_mon_1;
   reg [15:0]       n_mon_1;
   reg [15:0]       s_p_mon_1;
   wire [15:0]      s_out_mon_1;
   reg [15:0]       a_mon_2;
   reg [15:0]       b_mon_2;
   reg [15:0]       n_mon_2;
   reg [15:0]       s_p_mon_2;
   wire [15:0]      s_out_mon_2;
   wire [15:0]      fifo_1_in;
   wire [15:0]      fifo_2_in;
   wire [15:0]      fifo_1_out;
   wire [15:0]      exp_out;
   wire [15:0]      n_out;
   
   wire [31:0]      fifo_out;
   reg [31:0]       fifo_in;
   
   reg [5:0]        addr_exp;
   reg [5:0]        addr_n;
   reg [5:0]        next_addr_exp;
   reg [5:0]        next_addr_n;
   
   parameter [3:0]  state_type_wait_start = 0,
                    state_type_prepare_data = 1,
                    state_type_wait_constants = 2,
                    state_type_writting_cts_fifo = 3,
                    state_type_processing_data_0 = 4,
                    state_type_processing_data_1 = 5,
                    state_type_wait_results = 6,
                    state_type_transition = 7,
                    state_type_prepare_next = 8,
                    state_type_writting_results = 9,
                    state_type_final_mult = 10,
                    state_type_show_final = 11,
                    state_type_prepare_final = 12,
                    state_type_wait_final = 13;
   reg [3:0]        state;
   reg [3:0]        next_state;
   reg [7:0]        w_numb;
   reg [7:0]        next_w_numb;
   
   reg [15:0]       n_c_reg;
   reg [15:0]       next_n_c_reg;
   reg [15:0]       count_input;
   reg [15:0]       next_count_input;
   reg [15:0]       bit_counter;
   reg [15:0]       next_bit_counter;
   
   reg [15:0]       bsize_reg;
   reg [15:0]       next_bsize_reg;
   reg [0:0]        write_b_n;
   
   wire [15:0]      n_c_o;
   reg [15:0]       n_c;
   wire             n_c_load;
   
   
   n_c_core n_c1(.clk(clk), .m_lsw(m), .ce(start_in), .n_c(n_c_o), .done(n_c_load));
   
   
   montgomery_mult mon_1(.clk(clk), .reset(reset), .valid_in(valid_in_mon_1), .a(a_mon_1), .b(b_mon_1), .n(n_mon_1), .s_prev(s_p_mon_1), .n_c(n_c_reg), .s(s_out_mon_1), .valid_out(valid_out_mon_1));
   
   
   montgomery_mult mon_2(.clk(clk), .reset(reset), .valid_in(valid_in_mon_2), .a(a_mon_2), .b(b_mon_2), .n(n_mon_2), .s_prev(s_p_mon_2), .n_c(n_c_reg), .s(s_out_mon_2), .valid_out(valid_out_mon_2));
   
   
   res_out_fifo fifo_mon_out(.clk(clk), .rst(reset), .din(fifo_in), .wr_en(fifo_1_wr), .rd_en(fifo_1_rd), .dout(fifo_out));
   
   
   Mem_b exp(.clka(clk), .wea(write_b_n), .addra(addr_exp), .dina(y), .douta(exp_out));
   
   
   Mem_b n_mod(.clka(clk), .wea(write_b_n), .addra(addr_n), .dina(m), .douta(n_out));
   
   
   always @(posedge clk or reset)
      
      
      begin
         
         if (reset == 1'b1)
         begin
            state <= state_type_wait_start;
            n_c_reg <= {16{1'b0}};
            w_numb <= {8{1'b0}};
            count_input <= {16{1'b0}};
            addr_exp <= {6{1'b0}};
            addr_n <= {6{1'b0}};
            bit_counter <= {16{1'b0}};
            bsize_reg <= {16{1'b0}};
            n_c <= {16{1'b0}};
         end
         else
         begin
            
            if (n_c_load == 1'b1)
               n_c <= n_c_o;
            state <= next_state;
            n_c_reg <= next_n_c_reg;
            w_numb <= next_w_numb;
            count_input <= next_count_input;
            addr_exp <= next_addr_exp;
            addr_n <= next_addr_n;
            bit_counter <= next_bit_counter;
            bsize_reg <= next_bsize_reg;
         end
      end
   
   
   always @(state or bsize_reg or n_c_reg or valid_in or x or n_c or r_c or m or y or w_numb or count_input or addr_exp or addr_n or s_out_mon_1 or s_out_mon_2 or bit_size or valid_out_mon_1 or bit_counter or exp_out or fifo_out or n_out)
   begin: xhdl0
      
      reg [3:0]        mask;
      
      next_state <= state;
      next_n_c_reg <= n_c_reg;
      next_w_numb <= w_numb;
      next_count_input <= count_input;
      next_bsize_reg <= bsize_reg;
      valid_in_mon_1 <= 1'b0;
      valid_in_mon_2 <= 1'b0;
      a_mon_1 <= {16{1'b0}};
      b_mon_1 <= {16{1'b0}};
      n_mon_1 <= {16{1'b0}};
      a_mon_2 <= {16{1'b0}};
      b_mon_2 <= {16{1'b0}};
      n_mon_2 <= {16{1'b0}};
      s_p_mon_1 <= {16{1'b0}};
      s_p_mon_2 <= {16{1'b0}};
      fifo_1_rd <= 1'b0;
      fifo_in <= {32{1'b0}};
      fifo_1_wr <= 1'b0;
      write_b_n <= 1'b0;
      next_addr_exp <= addr_exp;
      next_addr_n <= addr_n;
      next_bit_counter <= bit_counter;
      valid_out <= 1'b0;
      s <= {16{1'b0}};
      case (state)
         
         state_type_wait_start :
            begin
               
               valid_in_mon_1 <= valid_in;
               valid_in_mon_2 <= valid_in;
               if (valid_in == 1'b1)
               begin
                  a_mon_1 <= x;
                  b_mon_1 <= r_c;
                  n_mon_1 <= m;
                  
                  a_mon_2 <= 16'h0001;
                  b_mon_2 <= r_c;
                  n_mon_2 <= m;
                  next_w_numb <= 8'h23;
                  next_n_c_reg <= n_c;
                  next_state <= state_type_prepare_data;
                  next_count_input <= 16'h0001;
                  
                  write_b_n <= 1'b1;
                  next_addr_exp <= 6'b000001;
                  next_addr_n <= 6'b000001;
                  next_bsize_reg <= bit_size - 1;
               end
            end
         
         state_type_prepare_data :
            begin
               next_count_input <= count_input + 1;
               valid_in_mon_1 <= 1'b1;
               valid_in_mon_2 <= 1'b1;
               if (valid_in == 1'b1)
               begin
                  a_mon_1 <= x;
                  b_mon_1 <= r_c;
                  n_mon_1 <= m;
                  b_mon_2 <= r_c;
                  n_mon_2 <= m;
                  
                  write_b_n <= 1'b1;
                  next_addr_exp <= addr_exp + 1;
                  next_addr_n <= addr_n + 1;
               end
               if (count_input == w_numb)
               begin
                  next_state <= state_type_wait_constants;
                  next_addr_n <= {6{1'b0}};
                  
                  next_addr_exp <= bsize_reg[9:4];
                  mask = bsize_reg[3:0];
                  case (mask)
                     4'b0000 :
                        next_bit_counter <= 16'b0000000000000001;
                     4'b0001 :
                        next_bit_counter <= 16'b0000000000000010;
                     4'b0010 :
                        next_bit_counter <= 16'b0000000000000100;
                     4'b0011 :
                        next_bit_counter <= 16'b0000000000001000;
                     4'b0100 :
                        next_bit_counter <= 16'b0000000000010000;
                     4'b0101 :
                        next_bit_counter <= 16'b0000000000100000;
                     4'b0110 :
                        next_bit_counter <= 16'b0000000001000000;
                     4'b0111 :
                        next_bit_counter <= 16'b0000000010000000;
                     4'b1000 :
                        next_bit_counter <= 16'b0000000100000000;
                     4'b1001 :
                        next_bit_counter <= 16'b0000001000000000;
                     4'b1010 :
                        next_bit_counter <= 16'b0000010000000000;
                     4'b1011 :
                        next_bit_counter <= 16'b0000100000000000;
                     4'b1100 :
                        next_bit_counter <= 16'b0001000000000000;
                     4'b1101 :
                        next_bit_counter <= 16'b0010000000000000;
                     4'b1110 :
                        next_bit_counter <= 16'b0100000000000000;
                     4'b1111 :
                        next_bit_counter <= 16'b1000000000000000;
                     default :
                        ;
                  endcase
                  next_count_input <= {16{1'b0}};
               end
            end
         
         state_type_wait_constants :
            
            if (valid_out_mon_1 == 1'b1)
            begin
               fifo_1_wr <= 1'b1;
               fifo_in <= {s_out_mon_1, s_out_mon_2};
               next_count_input <= count_input + 1;
               next_state <= state_type_writting_cts_fifo;
            end
         
         state_type_writting_cts_fifo :
            begin
               fifo_1_wr <= valid_out_mon_1;
               next_count_input <= count_input + 1;
               if (count_input < 8'h20)
                  fifo_in <= {s_out_mon_1, s_out_mon_2};
               
               if (valid_out_mon_1 == 1'b0)
               begin
                  next_count_input <= {16{1'b0}};
                  next_state <= state_type_transition;
               end
            end
         
         state_type_transition :
            begin
               
               next_count_input <= count_input + 1;
               
               if (count_input > 2)
               begin
                  next_count_input <= {16{1'b0}};
                  if ((bit_counter & exp_out) == 16'h0000)
                     next_state <= state_type_processing_data_0;
                  else
                     next_state <= state_type_processing_data_1;
               end
            end
         
         state_type_processing_data_1 :
            begin
               
               if (count_input > 16'h0000)
               begin
                  valid_in_mon_1 <= 1'b1;
                  valid_in_mon_2 <= 1'b1;
               end
               
               fifo_1_rd <= 1'b1;
               
               a_mon_1 <= fifo_out[31:16];
               b_mon_1 <= fifo_out[15:0];
               n_mon_1 <= n_out;
               
               a_mon_2 <= fifo_out[31:16];
               b_mon_2 <= fifo_out[31:16];
               n_mon_2 <= n_out;
               
               next_addr_n <= addr_n + 1;
               next_count_input <= count_input + 1;
               
               if (count_input == w_numb)
                  next_state <= state_type_wait_results;
            end
         
         state_type_processing_data_0 :
            begin
               
               if (count_input > 16'h0000)
               begin
                  valid_in_mon_1 <= 1'b1;
                  valid_in_mon_2 <= 1'b1;
               end
               
               fifo_1_rd <= 1'b1;
               
               a_mon_1 <= fifo_out[15:0];
               b_mon_1 <= fifo_out[15:0];
               n_mon_1 <= n_out;
               
               a_mon_2 <= fifo_out[31:16];
               b_mon_2 <= fifo_out[15:0];
               n_mon_2 <= n_out;
               
               next_addr_n <= addr_n + 1;
               next_count_input <= count_input + 1;
               
               if (count_input == w_numb)
               begin
                  next_state <= state_type_wait_results;
                  next_count_input <= {16{1'b0}};
               end
            end
         
         state_type_wait_results :
            
            if (valid_out_mon_1 == 1'b1)
            begin
               fifo_1_wr <= 1'b1;
               fifo_in <= {s_out_mon_2, s_out_mon_1};
               next_count_input <= 16'h0001;
               next_state <= state_type_writting_results;
            end
         
         state_type_writting_results :
            begin
               
               next_addr_n <= {6{1'b0}};
               fifo_1_wr <= valid_out_mon_1;
               next_count_input <= count_input + 1;
               if (count_input < 8'h20)
                  fifo_in <= {s_out_mon_2, s_out_mon_1};
               
               if (valid_out_mon_1 == 1'b0)
               begin
                  next_count_input <= {16{1'b0}};
                  next_state <= state_type_prepare_next;
                  next_bit_counter <= {1'b0, bit_counter[15:1]};
                  if (bit_counter == 16'h0001)
                  begin
                     next_addr_exp <= addr_exp - 1;
                     next_bit_counter <= 16'b1000000000000000;
                  end
                  if ((bit_counter == 16'h0001) & addr_exp == 9'b000000000)
                  begin
                     next_state <= state_type_final_mult;
                     next_count_input <= {16{1'b0}};
                     next_addr_exp <= {6{1'b0}};
                  end
               end
            end
         
         state_type_prepare_next :
            begin
               next_state <= state_type_transition;
               next_count_input <= {16{1'b0}};
               fifo_1_rd <= 1'b0;
            end
         
         state_type_final_mult :
            begin
               next_count_input <= count_input + 1;
               
               if (count_input > 2)
               begin
                  next_count_input <= {16{1'b0}};
                  next_state <= state_type_prepare_final;
               end
            end
         
         state_type_prepare_final :
            begin
               
               if (count_input > 16'h0000)
                  valid_in_mon_1 <= 1'b1;
               
               fifo_1_rd <= 1'b1;
               
               a_mon_1 <= fifo_out[15:0];
               if (count_input == 16'h0001)
                  b_mon_1 <= 16'h0001;
               n_mon_1 <= n_out;
               
               next_addr_n <= addr_n + 1;
               next_count_input <= count_input + 1;
               
               if (count_input == w_numb)
               begin
                  next_state <= state_type_wait_final;
                  next_count_input <= {16{1'b0}};
               end
            end
         
         state_type_wait_final :
            
            if (valid_out_mon_1 == 1'b1)
            begin
               valid_out <= 1'b1;
               s <= s_out_mon_1;
               next_state <= state_type_show_final;
               next_count_input <= count_input + 1;
            end
         
         state_type_show_final :
            begin
               valid_out <= 1'b1;
               s <= s_out_mon_1;
               next_count_input <= count_input + 1;
               if (count_input == 8'h20)
               begin
                  valid_out <= 1'b0;
                  next_state <= state_type_wait_start;
               end
            end
      endcase
   end
   
endmodule


