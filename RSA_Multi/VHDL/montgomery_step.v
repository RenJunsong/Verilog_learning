//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// ?? 4? 28 2020 14:37:49
//
//      Input file      : 
//      Component name  : montgomery_step
//      Author          : 
//      Company         : 
//
//      Description     : 
//
//
//--------------------------------------------------------------------------------------------


module montgomery_step(clk, reset, valid_in, a, b, n, s_prev, n_c, s, valid_out, busy, b_req, a_out, n_out, c_step, stop);
   input            clk;
   input            reset;
   input            valid_in;
   input [15:0]     a;
   input [15:0]     b;
   input [15:0]     n;
   input [15:0]     s_prev;
   input [15:0]     n_c;
   output [15:0]    s;
   output           valid_out;
   reg              valid_out;
   output           busy;
   reg              busy;
   output           b_req;
   reg              b_req;
   output [15:0]    a_out;
   reg [15:0]       a_out;
   output [15:0]    n_out;
   reg [15:0]       n_out;
   output           c_step;
   reg              c_step;
   input            stop;
   
   
   reg              ab_valid;
   reg              valid_mont;
   wire             fifo_read;
   wire             m_val;
   wire             valid_mont_out;
   reg              reset_pe;
   
   parameter [2:0]  state_type_wait_valid = 0,
                    state_type_wait_m = 1,
                    state_type_mont_proc = 2,
                    state_type_getting_results = 3,
                    state_type_prep_m = 4,
                    state_type_b_stable = 5;
   reg [2:0]        state;
   reg [2:0]        next_state;
   reg [7:0]        counter;
   reg [7:0]        next_counter;
   
   reg [15:0]       mont_input_a;
   reg [15:0]       mont_input_n;
   reg [15:0]       mont_input_s;
   reg [47:0]       reg_constant;
   reg [47:0]       next_reg_constant;
   reg [47:0]       next_reg_input;
   reg [47:0]       reg_input;
   reg [31:0]       reg_out;
   reg [31:0]       reg_out_1;
   reg [31:0]       reg_out_2;
   reg [31:0]       reg_out_3;
   reg [31:0]       reg_out_4;
   wire [31:0]      next_reg_out;
   
   reg [47:0]       reg_input_1;
   reg [47:0]       reg_input_2;
   reg [47:0]       reg_input_3;
   reg [47:0]       reg_input_4;
   reg [47:0]       reg_input_5;
   
   
   pe_wrapper mont(.clk(clk), .reset(reset), .ab_valid(ab_valid), .a(mont_input_a), .b(b), .n(mont_input_n), .s_prev(mont_input_s), .n_c(n_c), .s(s), .valid_in(valid_mont), .data_ready(valid_mont_out), .m_val(m_val), .reset_the_pe(reset_pe));
   
   
   always @(posedge clk or reset)
      
      begin
         
         if (reset == 1'b1)
         begin
            state <= state_type_wait_valid;
            counter <= {8{1'b0}};
            reg_constant <= {48{1'b0}};
            reg_input <= {48{1'b0}};
            reg_input_1 <= {48{1'b0}};
            reg_input_2 <= {48{1'b0}};
            reg_input_3 <= {48{1'b0}};
            reg_input_4 <= {48{1'b0}};
            
            reg_out <= {32{1'b0}};
            reg_out_1 <= {32{1'b0}};
            reg_out_2 <= {32{1'b0}};
            reg_out_3 <= {32{1'b0}};
            reg_out_4 <= {32{1'b0}};
         end
         else
         begin
            
            reg_input <= next_reg_input;
            reg_input_1 <= reg_input;
            reg_input_2 <= reg_input_1;
            reg_input_3 <= reg_input_2;
            reg_input_4 <= reg_input_3;
            reg_input_5 <= reg_input_4;
            
            reg_out <= {reg_input_4[47:32], reg_input_4[31:16]};
            reg_out_1 <= reg_out;
            reg_out_2 <= reg_out_1;
            reg_out_3 <= reg_out_2;
            reg_out_4 <= reg_out_3;
            
            state <= next_state;
            counter <= next_counter;
            reg_constant <= next_reg_constant;
         end
      end
   
   
   always @(state or valid_in or m_val or a or n or s_prev or counter or valid_mont_out or stop or reg_constant or reg_input_5 or reg_out_4)
   begin
      next_reg_input <= {a, n, s_prev};
      
      a_out <= reg_out_4[31:16];
      n_out <= reg_out_4[15:0];
      
      next_state <= state;
      next_counter <= counter;
      ab_valid <= 1'b0;
      valid_mont <= 1'b0;
      valid_out <= 1'b0;
      reset_pe <= 1'b0;
      busy <= 1'b1;
      b_req <= 1'b0;
      c_step <= 1'b0;
      
      mont_input_a <= {16{1'b0}};
      mont_input_n <= {16{1'b0}};
      mont_input_s <= {16{1'b0}};
      next_reg_constant <= reg_constant;
      
      case (state)
         state_type_wait_valid :
            begin
               busy <= 1'b0;
               reset_pe <= 1'b1;
               if (valid_in == 1'b1)
               begin
                  
                  b_req <= 1'b1;
                  next_state <= state_type_b_stable;
                  next_reg_constant <= {a, n, s_prev};
               end
            end
         state_type_b_stable :
            next_state <= state_type_prep_m;
         state_type_prep_m :
            begin
               mont_input_a <= reg_constant[47:32];
               mont_input_n <= reg_constant[31:16];
               mont_input_s <= reg_constant[15:0];
               ab_valid <= 1'b1;
               next_state <= state_type_wait_m;
            end
         state_type_wait_m :
            begin
               
               mont_input_a <= reg_constant[47:32];
               mont_input_n <= reg_constant[31:16];
               mont_input_s <= reg_constant[15:0];
               
               if (m_val == 1'b1)
               begin
                  
                  valid_mont <= 1'b1;
                  next_state <= state_type_mont_proc;
                  mont_input_a <= reg_input_5[47:32];
                  mont_input_n <= reg_input_5[31:16];
                  mont_input_s <= reg_input_5[15:0];
               end
            end
         
         state_type_mont_proc :
            begin
               
               valid_mont <= 1'b1;
               mont_input_a <= reg_input_5[47:32];
               mont_input_n <= reg_input_5[31:16];
               mont_input_s <= reg_input_5[15:0];
               
               if (valid_mont_out == 1'b1)
               begin
                  
                  next_counter <= 8'h00;
                  next_state <= state_type_getting_results;
               end
            end
         
         state_type_getting_results :
            begin
               
               valid_out <= 1'b1;
               next_counter <= counter + 1;
               valid_mont <= 1'b1;
               
               mont_input_a <= reg_input_5[47:32];
               mont_input_n <= reg_input_5[31:16];
               mont_input_s <= reg_input_5[15:0];
               
               if (counter == (8'h22))
               begin
                  next_state <= state_type_wait_valid;
                  c_step <= 1'b1;
                  reset_pe <= 1'b1;
               end
            end
      endcase
      
      if (stop == 1'b1)
      begin
         next_state <= state_type_wait_valid;
         reset_pe <= 1'b1;
      end
   end
   
endmodule
